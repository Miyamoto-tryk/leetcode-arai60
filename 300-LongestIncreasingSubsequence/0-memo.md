# 300. Longest Increasing Subsequence
# はじめに
 - Step1
     - 初見で解く
     - 知らなければできないことは調べる
 - Step2
     - なんでも使ってコードを洗練させる
 - Step3
     - 何も見ずにStep1の思考でStep2と同等のコードを3回繰り返してすらすら書く

# step1
パッとすぐには解き方が思いつかなかった。
しばらく考えていると、
数列をindexが小さい方から見ていき、
すでに見た部分でのLISに、今見ている数字をくっつけて新たなLISを作ることを考える
と、
各「暫定のLISの長さ」ごとの「末尾の最小値」を記憶すれば良く、
数字をindexの小さい方から一つずつ見ていって上記を記憶する配列を計算していく方法に考えついた。

ロジックをコードに落とし込むのに精一杯で、かなり汚いコードになってしまった。
O(n^2)だが入力も最大2500とそこまで大きくない。

ここまで30分ほど。
他の方法は、思いつかない。
# step2
とりあえず、洗練させる。
不必要な更新操作を早めにbreakさせたりした
「暫定のLISの長さ」ごとの「末尾の最小値」を記憶する配列が`length_to_min`は分かりやすくないかもしれないが、他に良い名前が思いつかない。

# 他の人の回答を見る
https://github.com/tarinaihitori/leetcode/pull/31/files
> 「位置 i で終わる増加部分列の最長長さ」を状態として定義すると、
 末尾を i に固定したとき、その長さは “i より前にあって、かつ nums[j] < nums[i] を満たす j の中で最も長い増加部分列長 + 1”
 という形で再帰的に書けるとわかった。

たしかに。`dp-0.cpp`に書いてみた。dp配列から最大要素をとるのに`max_element()`を使用したが、リファレンスを見てみるとO(N)かかるらしい。知らなかった。
ソートしてから先頭or末尾の要素を取得する方が早いが、せっかく作成したDP列をソートしてしまうのも勿体無い。<https://cpprefjp.github.io/reference/algorithm/max_element.html>

> 二分探索でもいけるらしい

二分探索でいけると言われてもパッと思いつかないので調べてみる。<https://qiita.com/kgoto/items/d1e9d39b8b391fc19970>
このやり方だと、LISを実際に出力することもできる。
`binary-0.cpp`
二分探索の方法はstep1,2とやりたいことは同じだが、より無駄なく高速に出来ている。

動的計画法の方が読みやすく分かりやすいかな

# step3
動的計画法ので3回書きなおす

# 4-binary.cpp
コメントをもとに書き直した
良い変数名が思いつかず、またそれを説明する良いコメントもなかなか思いつかない
```cpp
// 末尾の最小値をnumに更新できるlengthのiterator
      auto new_LIS_itr =
          upper_bound(length_to_min_last_num.begin(), length_to_min_last_num.end(), num - 1);
```
としたが、あまり分かりやすくないように感じる


# 4-dp.cpp
変数名を変えた




