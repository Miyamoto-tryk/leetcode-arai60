# 2. Add Two Numbers
# はじめに
 - Step1
     - 初見で解く
     - 知らなければできないことは調べる
 - Step2
     - なんでも使ってコードを洗練させる
 - Step3
     - 何も見ずにStep1の思考でStep2と同等のコードを3回繰り返してすらすら書く

# step1
桁上げ（carry）の有無を計算しつつ、順次、各桁の和を計算していけばいいと思った。
while文で桁上げしていこうかと思ったが、再帰で書けば綺麗に書けるかもと思い、再帰で書き始めたが、うまく書けなかった。

あきらめてwhile文で書こうと思ったが、構造体とそのポインタについてしっかり理解できておらず、書ききれなかった。

l1もl2もnullだがcarry=1の場合　などの考慮が漏れていた。

答えを見て理解し、一から書き直す、といったことを2回ほど繰り返して、答えを書けるようになった。

その後、再び再帰での回答を`step1-1.cpp`に書いてみた。
再帰だと、`addTwoNumbers()`の引数を変えられないので、グローバルにcarryを保持しておく必要があり良くない

解答をかけなかった理由としてはC++のポインタや構造体についての理解が甘かったのが大きいと思う。

# step2
少し時間が空いてしまったので一から書き直してみる
### step2-0.cpp
ノンストップでは書けなかった。

答えのListNodeをnewで構築するのは、newで宣言した構造体はヒープにメモリが確保され、スコープから外れた後も残るため。
今回のようにポインタを返す必要がある場合は、newで初期化する必要がある。

逆にnewを使わず`ListNode list_node = ListNode(0)`のような初期化を行うと、メモリがスタックに確保されるため、スコープから外れた際にメモリが解放されてしまう。今回のように最終的に構造体のポインタを返す必要がある場合、スタックに確保した構造体のポインタを返しても、ポインタの先には何もないみたいなことになってしまうのだと理解
### step2-1.cpp
dummyHeadを作成して、while文の中では next を new ListNode() で置き換えていく　というのが自然な発想としてなかなかしっくりこなかった。結局このやり方が一番書きやすいが、そこに自然に至らなかった。

まず、一番最初のノードとして一桁目のノードをwhile文の中で作成すると、、whileから抜けた後困るので、while文のそとで一番最初のノードとして`dummyHead`を宣言。その後、各桁のノード作成をwhile文で回す。各ループ時点で前の桁のノードは生成されてるので、前の桁のノードのnextを今回作成したノードとする。という流れで理解

今回作成したノードのnextを、次のノードへのポインタとする、というよりは
一つ前の桁のノードのnextを、今回作成したノードへのポインタとする
という考え方。ノード作成時点では前の桁のノードは作成されてるが、次の桁のノードは作成されていないので、後者の方が自然。ということで理解

### step2-rec-0.cpp
よく考えたら、引数にcarryを含めた「再帰で計算する用の関数」を新しく定義すれば、`step1-rec.cpp`みたいにcarryをグローバルに保持する必要がないことに気づいた。順次桁上げの加算を行う関数の引数がl1,l2,carryになってしっくり来る。
自分で関数を定義する、という発想が抜けていた。

ただ、while文で書く方が良い回答な気はする。主に再帰が深すぎる場合のスタックオーバーフロー。

```cpp
return new ListNode(sum % 10, recursiveAddTwoNumbers(l1, l2, carry));
```
では末尾再帰になっていないと思うので、末尾再帰にすると`step2-rec-1.cpp`みたいになるか。while文で書くのと全く同じ処理。

# 他の人の回答を見る
> 再帰をすると、少し面倒になるのがデバッグのためのログ関数を挟むときなどです。
なので、単純なループに近いときには再帰でわざわざ書くことはあまりないとは思います。ただ結構考えるときには使っています。

確かに。再帰→末尾再帰の流れで考えると、while文で書くLeetCodeの模範回答とほぼ同じ処理になった。再帰からの方が考えやすい時は確かにあるし、まずは再帰で考えてみて、ループに置き換えるというのも有効だと感じた。

> これは、単に
ListNode sentinel;
という風にポインターではなくて宣言して
return sentinel->next;
とすればいいです。
デフォルトコンストラクタが定義されているので初期化もされます。

確かに。思いつかなかった。

# step3
`current`は`previous`の方が自然か。。。

以上までを踏まえで3回書き直した



